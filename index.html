<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Minimal Slope 3D</title>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; touch-action:none; }
  #score { position:absolute; top:20px; left:20px; color:#0f0; font-size:24px; z-index:2; }
  #fullscreenBtn { position:absolute; top:20px; right:20px; padding:10px 20px; font-size:16px; z-index:2; cursor:pointer; background:#0f0; color:black; border:none; border-radius:5px; }
  #fullscreenBtn:hover { background:#0c0; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<button id="fullscreenBtn">Fullscreen</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,5,15);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Light
const light = new THREE.PointLight(0x00ff00, 2, 100);
light.position.set(0,10,20);
scene.add(light);

// Ball
const ballGeo = new THREE.SphereGeometry(1,32,32);
const ballMat = new THREE.MeshStandardMaterial({color:0x00ff00, emissive:0x00ff00, emissiveIntensity:1});
const ball = new THREE.Mesh(ballGeo, ballMat);
ball.position.set(0,1,0);
scene.add(ball);

// Platforms
const platformWidth = 10;
const platformLength = 20;
let platforms = [];
function createPlatform(z) {
  const geo = new THREE.BoxGeometry(platformWidth,1,platformLength);
  const mat = new THREE.MeshStandardMaterial({color:0x1111ff, emissive:0x1111ff, emissiveIntensity:0.5});
  const p = new THREE.Mesh(geo, mat);
  p.position.z = z;
  scene.add(p);
  platforms.push(p);
}
for(let i=0;i<20;i++) createPlatform(-i*platformLength);

// Controls
let move=0;
document.addEventListener("keydown", e => { if(e.key==="ArrowLeft") move=-0.3; if(e.key==="ArrowRight") move=0.3; });
document.addEventListener("keyup", ()=> move=0);

// Touch controls
let touchStartX=null;
document.addEventListener("touchstart", e => { touchStartX = e.touches[0].clientX; });
document.addEventListener("touchmove", e => { if(touchStartX!==null) { move = (e.touches[0].clientX - touchStartX)*0.002; } });
document.addEventListener("touchend", ()=>{ move=0; touchStartX=null; });

// Fullscreen
document.getElementById("fullscreenBtn").addEventListener("click", () => {
  if(!document.fullscreenElement) document.body.requestFullscreen();
  else document.exitFullscreen();
});

// Score
let score = 0;
const scoreEl = document.getElementById("score");

// Animate
let speed = 0.5;
function animate() {
  requestAnimationFrame(animate);

  ball.position.x += move;

  // Move platforms
  platforms.forEach(p => {
    p.position.z += speed;
    if(p.position.z > 10) {
      p.position.z -= 20*platforms.length;
    }
  });

  // Increase speed and score
  speed += 0.001;
  score += Math.floor(speed*2);
  scoreEl.textContent = "Score: " + score;

  // Simple collision/fall detection
  let onPlatform = false;
  for(let p of platforms){
    if(ball.position.x+1 > p.position.x - platformWidth/2 &&
       ball.position.x-1 < p.position.x + platformWidth/2 &&
       ball.position.z+1 > p.position.z - platformLength/2 &&
       ball.position.z-1 < p.position.z + platformLength/2){
         onPlatform = true; break;
       }
  }
  if(!onPlatform){
    alert("Game Over! Score: " + score);
    location.reload();
  }

  // Camera follows ball
  camera.position.x = ball.position.x;
  camera.position.z = ball.position.z + 15;
  camera.position.y = ball.position.y + 5;
  camera.lookAt(ball.position);

  renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener("resize", ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
